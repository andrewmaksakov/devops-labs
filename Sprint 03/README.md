# Sprint 03 — Сеть: порты, DNS, HTTP, TLS, диагностика

**Цель:** уметь чинить "не открывается сайт / не ходит запрос"

**Длительность:** 2 недели

---

## Теория

### Как работает запрос к сайту

```
Пользователь вбил https://example.com/api
        ↓
1. DNS-резолвинг   → "какой IP у example.com?"  → 93.184.216.34
        ↓
2. TCP-соединение  → подключение к 93.184.216.34:443
        ↓
3. TLS-handshake   → проверка сертификата + шифрование
        ↓
4. HTTP-запрос     → GET /api HTTP/1.1 → ответ 200 OK
```

Если "не работает" — ломается один из этих шагов. Для каждого есть свой инструмент.

### Инструменты диагностики — шпаргалка

| Инструмент | Что делает | Когда использовать | Аналогия |
|------------|-----------|-------------------|----------|
| `ip` | Показывает сетевые интерфейсы, IP-адреса и маршруты твоей машины | "Какой у меня IP? Сеть вообще поднялась?" — самый первый шаг | Посмотреть свой паспорт — "кто я в этой сети?" |
| `ss` | Показывает какие порты слушают программы и текущие соединения | "Nginx вообще запустился? На каком порту висит?" | Посмотреть какие двери в доме открыты и кто за ними стоит |
| `dig` | Спрашивает DNS-сервер "какой IP у этого домена?" | "Сайт не открывается — DNS вообще резолвится?" | Позвонить в справочную и спросить номер телефона по имени |
| `curl` | Отправляет HTTP-запрос и показывает ответ (код, заголовки, тело) | "Сервер отвечает? Какой код? Что в ответе?" — главный инструмент отладки HTTP | Позвонить по номеру и послушать что ответят |
| `traceroute` | Показывает через какие узлы идёт пакет от тебя до цели | "Пакеты не доходят — где именно застревают?" | Отследить посылку: склад → сортировка → машина → почта → адресат |
| `tcpdump` | Перехватывает и показывает каждый сетевой пакет | Когда ничего другое не помогло. "Что вообще летит по сети?" — тяжёлая артиллерия | Рентген: видишь каждый байт который проходит через провод |

**Порядок диагностики "сайт не работает":**
```
1. ip addr          → у меня есть IP? сеть поднялась?
2. dig domain.com   → DNS резолвится?
3. ping domain.com  → хост живой?
4. ss -tlnp         → сервис слушает порт?
5. curl -v http://  → что отвечает? какой код?
6. traceroute       → где застревает трафик?
7. tcpdump          → что вообще летит по сети? (крайний случай)
```

---

### 1. Сетевые интерфейсы и IP

Каждая машина имеет сетевые интерфейсы — это "точки подключения" к сети.

```bash
ip addr                  # Показать все интерфейсы и их IP-адреса
ip route                 # Таблица маршрутизации (куда идёт трафик)
ip link                  # Состояние интерфейсов (up/down)
```

**Типичные интерфейсы:**
| Интерфейс | Описание |
|-----------|----------|
| `lo` | Loopback — localhost (127.0.0.1), только для себя |
| `eth0` | Проводная сеть (в WSL это основной интерфейс) |
| `wlan0` | Wi-Fi (если есть) |
| `docker0` | Docker bridge сеть (появится в Sprint 06) |

**Что такое порт?**

IP-адрес — это адрес машины. Порт — это "дверь" на машине для конкретного сервиса.

- `80` — HTTP
- `443` — HTTPS
- `22` — SSH
- `5432` — PostgreSQL
- `3000-9000` — обычно приложения

Аналогия: IP = адрес дома, порт = номер квартиры.

---

### 2. Порты и соединения (ss)

`ss` (socket statistics) — смотрим кто слушает какие порты и текущие соединения.

```bash
ss -tlnp                 # TCP, Listening, Numeric, Process
                         # -t = TCP
                         # -l = только слушающие (LISTEN)
                         # -n = показывать номера портов (не имена)
                         # -p = показывать процесс

ss -tunap                # Все соединения (TCP + UDP), все состояния
```

**Пример вывода `ss -tlnp`:**
```
State   Local Address:Port   Process
LISTEN  0.0.0.0:80           nginx
LISTEN  0.0.0.0:22           sshd
LISTEN  127.0.0.1:8000       python3
```

Здесь видно:
- Nginx слушает порт 80 **на всех интерфейсах** (0.0.0.0)
- Python слушает порт 8000 **только на localhost** (127.0.0.1) — снаружи не доступен

---

### 3. DNS

DNS (Domain Name System) — "телефонная книга интернета". Переводит имена в IP.

**Типы записей:**

| Запись | Что делает | Пример | Когда нужно | Аналогия |
|--------|-----------|--------|-------------|----------|
| `A` | Переводит имя сайта в IPv4-адрес (обычный короткий IP). Самая главная запись — без неё сайт не откроется | `google.com → 142.251.142.110` | Всегда. Каждый сайт имеет A-запись | Телефонная книга: "Вася" → 8-999-111-22-33 |
| `AAAA` | То же самое что A, но для IPv6 (новый длинный формат IP). Придумали потому что старых коротких адресов на всех не хватило | `google.com → 2a00:1450:4017:817::200e` | Когда сервер поддерживает IPv6. Пока можно не думать — A хватает | Тот же Вася, но номер в новом формате |
| `CNAME` | Ссылка на другое имя. НЕ IP-адрес, а "это то же самое что вон тот домен". DNS идёт по ссылке и уже там находит IP | `www.github.com → github.com → 140.82.121.4` | Когда хочешь чтобы несколько имён вели в одно место, и при смене IP менять только в одном месте | Записка на двери: "Вася переехал к Пете" → идёшь к Пете |
| `MX` | Указывает куда доставлять почту для этого домена. Не для сайтов, только для email | `gmail.com → gmail-smtp-in.l.google.com` | Когда домен принимает почту (vasya@mysite.com) | Табличка "Почтовые ящики — в соседнем здании" |
| `NS` | Указывает какой DNS-сервер отвечает за этот домен. Работает "за кулисами" | `google.com → ns1.google.com` | Настраивается при покупке домена, потом не трогаешь | "По вопросам об этом доме — обращайтесь к управляющему" |

**TTL (Time To Live)** — таймер на каждой DNS-записи. Говорит "столько секунд можешь не спрашивать заново — ответ не изменится". TTL=300 значит "5 минут можешь не проверять". Важно при переезде сайта на новый сервер — если TTL большой, люди ещё долго ходят на старый IP.

```bash
dig example.com          # Запрос DNS (подробный)
dig +short example.com   # Только IP
dig example.com A        # Конкретный тип записи
dig @8.8.8.8 example.com # Спросить у конкретного DNS-сервера
nslookup example.com     # Простой DNS-запрос (устаревший, но работает)
```

**Файл `/etc/resolv.conf`** — какие DNS-серверы использует система:
```
nameserver 8.8.8.8
nameserver 8.8.4.4
```

---

### 4. HTTP

HTTP (HyperText Transfer Protocol) — протокол общения браузера с сервером.

**Структура запроса:**
```
GET /api/users HTTP/1.1       ← метод, путь, версия
Host: example.com             ← заголовки
Accept: application/json
Authorization: Bearer <token>
                              ← пустая строка
                              ← тело (для POST/PUT)
```

**Структура ответа:**
```
HTTP/1.1 200 OK               ← статус
Content-Type: application/json ← заголовки
Content-Length: 42
                               ← пустая строка
{"users": [...]}               ← тело
```

**Коды ответов:**
| Код | Значение | Когда |
|-----|----------|-------|
| `200` | OK | Всё хорошо |
| `301` | Moved Permanently | Редирект навсегда (HTTP → HTTPS) |
| `302` | Found | Временный редирект |
| `304` | Not Modified | Используй кеш |
| `400` | Bad Request | Кривой запрос от клиента |
| `401` | Unauthorized | Не авторизован |
| `403` | Forbidden | Доступ запрещён |
| `404` | Not Found | Страница не найдена |
| `500` | Internal Server Error | Сервер сломался |
| `502` | Bad Gateway | Прокси не может достучаться до backend |
| `503` | Service Unavailable | Сервис перегружен / на обслуживании |
| `504` | Gateway Timeout | Прокси ждал backend, но тот не ответил |

**curl — главный инструмент для отправки HTTP-запросов из терминала (как браузер, только в командной строке).**

**Флаги curl:**

| Флаг | Что делает | Пример |
|------|-----------|--------|
| (без флагов) | Простой GET-запрос, показывает тело ответа | `curl http://localhost` |
| `-v` | Verbose — показывает весь диалог: что отправил клиент (`>`), что ответил сервер (`<`) | `curl -v http://localhost` |
| `-s` | Silent — убирает прогресс-бар, чистый вывод | `curl -s http://localhost` |
| `-o /dev/null` | Не показывать тело ответа (выкинуть в никуда) | `curl -s -o /dev/null http://localhost` |
| `-w "%{http_code}"` | Вывести только код ответа (200, 404, 502...) | `curl -s -o /dev/null -w "%{http_code}" http://localhost` |
| `-I` | Только заголовки ответа, без тела | `curl -I http://localhost` |
| `-k` | Игнорировать ошибки сертификата (для self-signed) | `curl -k https://localhost` |
| `-L` | Следовать за редиректами (301, 302) | `curl -L http://localhost` |
| `-X POST` | Указать метод запроса (POST, PUT, DELETE) | `curl -X POST http://localhost/api` |
| `-d '...'` | Отправить данные в теле запроса | `curl -X POST -d '{"key":"val"}' http://localhost/api` |
| `-H "..."` | Добавить заголовок к запросу | `curl -H "Content-Type: application/json" http://localhost` |

**Частые комбинации:**
```bash
# Узнать только код ответа
curl -s -o /dev/null -w "%{http_code}\n" http://localhost

# Посмотреть весь диалог с HTTPS (self-signed)
curl -vk https://localhost

# Пойти за редиректом HTTP → HTTPS (self-signed)
curl -skL http://localhost
```

---

### 5. TLS/SSL

TLS (Transport Layer Security) — шифрование трафика. HTTPS = HTTP + TLS.

**Зачем:** без TLS трафик летит открытым текстом — любой на пути видит пароли, куки, данные.

**Как работает (упрощённо):**
1. Клиент подключается к серверу
2. Сервер показывает сертификат ("я точно example.com, вот доказательство")
3. Клиент проверяет: сертификат подписан доверенным CA? Не истёк? Имя совпадает?
4. Если всё ок — договариваются о шифровании, дальше трафик зашифрован

**Self-signed сертификат** — подписан сам собой, не доверенным CA. Браузер покажет предупреждение, но шифрование работает. Для dev/тестов — нормально.

```bash
# Проверить сертификат сайта
openssl s_client -connect example.com:443 -servername example.com </dev/null 2>/dev/null | openssl x509 -text -noout

# Проверить срок действия
echo | openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -dates -noout
```

---

### 6. Nginx и reverse proxy

**Nginx** — это программа (веб-сервер). Устанавливается на сервер, слушает порты 80/443, обрабатывает HTTP-запросы.

**Reverse proxy** — это НЕ отдельная программа, а **роль**. Как "охранник" — это роль, а "Вася" — конкретный человек. Nginx — программа, которая выполняет роль reverse proxy. Другие программы тоже умеют: HAProxy, Traefik, Caddy, Apache. Но Nginx — самый популярный.

**Что умеет Nginx:**

| Роль | Что делает | Пример |
|------|-----------|--------|
| Отдавать статику | HTML, CSS, картинки — отдаёт файлы напрямую клиенту, быстро | Клиент просит `index.html` → Nginx отдаёт из папки `/var/www/html/` |
| Reverse proxy | Принимает запрос, передаёт backend-у, возвращает ответ клиенту | Клиент → Nginx :443 → Python :8000 → ответ обратно |
| Балансировщик | Раскидывает запросы между несколькими backend-ами | Nginx → Backend 1 / Backend 2 / Backend 3 |

**Как работает reverse proxy:**
```
Клиент → Nginx (:80/:443) → Приложение (:8000)
```
Клиент даже не знает что за Nginx кто-то стоит. Думает что общается с Nginx напрямую.

**Зачем ставить Nginx перед backend-ом, а не выставлять backend напрямую в интернет?**

| Проблема | Без Nginx | С Nginx |
|----------|----------|---------|
| HTTPS | Python `http.server` не умеет TLS | Nginx шифрует, backend получает обычный HTTP |
| Много соединений | Python плохо держит тысячи подключений | Nginx оптимизирован под это |
| Статика (картинки, CSS) | Backend тратит ресурсы на отдачу файлов | Nginx отдаёт файлы в 10 раз быстрее |
| Backend упал | Клиент видит "Connection refused" | Nginx возвращает красивую ошибку 502 |

**На проде всегда стоит Nginx (или аналог) перед backend-ом.** Никто не выставляет Python/Node.js напрямую в интернет.

---

### 7. Диагностика (traceroute, tcpdump)

```bash
traceroute example.com   # Маршрут пакета до цели (через какие узлы)
mtr example.com          # traceroute + ping в реальном времени

tcpdump -i eth0 port 80  # Перехват трафика на порту 80
tcpdump -i any -n host 10.0.0.1   # Трафик к/от конкретного хоста
```

`tcpdump` — "рентген" сети. Показывает каждый пакет. Используй когда ничего другое не помогло.

---

## Практические задания

### 1. Установить и настроить Nginx

Поставить Nginx, настроить как reverse proxy для простого backend (`python3 -m http.server 8000`).

### 2. Настроить HTTPS с self-signed сертификатом

Сгенерировать сертификат, настроить Nginx для HTTPS, проверить через curl.

### 3. Создать network-cheatsheet.md

10 команд для диагностики сети — "шпаргалка на каждый день".

### 4. Документировать типичные проблемы

`troubleshooting.md` — типовые сетевые проблемы и как их решать.

---

## Структура папки

```
Sprint 03/
├── README.md                  # Теория + задания
├── configs/
│   ├── nginx.conf             # Основной конфиг Nginx
│   └── myapp-proxy.conf       # Конфиг reverse proxy + TLS
├── scripts/
│   └── gen-cert.sh            # Генерация self-signed сертификата
├── network-cheatsheet.md      # 10 команд диагностики
└── troubleshooting.md         # Типовые сетевые проблемы
```

---

## Как развернуть

```bash
# 1. Установить Nginx
sudo apt update && sudo apt install -y nginx

# 2. Сгенерировать сертификат
bash scripts/gen-cert.sh

# 3. Скопировать конфиги
sudo cp configs/myapp-proxy.conf /etc/nginx/sites-available/myapp
sudo ln -sf /etc/nginx/sites-available/myapp /etc/nginx/sites-enabled/myapp
sudo rm -f /etc/nginx/sites-enabled/default

# 4. Проверить конфиг и перезапустить
sudo nginx -t
sudo systemctl restart nginx

# 5. Запустить backend
python3 -m http.server 8000 &

# 6. Проверить
curl -v http://localhost
curl -vk https://localhost
```

---

## Экзамен (самопроверка)

- [x] `curl http://localhost` возвращает ответ от backend через Nginx
- [x] `curl -k https://localhost` работает (self-signed TLS)
- [x] `ss -tlnp` показывает Nginx на портах 80 и 443
- [x] `dig` возвращает DNS-записи для любого домена
- [x] Могу объяснить разницу между 502 и 504
- [x] Могу объяснить что делает reverse proxy
- [x] `openssl s_client` показывает сертификат
